from ware peter ware subject frequently asked question faq archive-name xt-faq version id faq-xt v ware exp the x toolkit intrinsic a monthly post thi article contain the answer to some frequently asked question faq from about the x toolkit intrinsic to submit question preferably with an answer send email to ware many faq include thi one be available on the archive site in the directory the name under which a faq be archive appear in the archive-name line at the top of the article thi faq be archive a xt-faq all code fragment be public domain content xt glossary software version related faq why do my application core dump when i use how do i use a different visual than the default which visual should an application use why do only shell widget have a visual which visual depth and colormap do shell inherit i do all the above and i still get a badmatch error why why do my widget get destroy when i call xtdestroywidget how do i exit but still execute the destroycallback how do i resize a shell widget why ca xtappaddinput handle file what good book and magazine be there on xt what widget be available what alternative to the intrinsic be there how do i pa a float value to xtsetvalue how do i write a resource converter how do i open multiple display what change from to to where be the resource load from what order be callback execute in how do i know if a widget be visible how do i reparent a widget in xt xtreparentwidget why use xtmalloc xtfree etc how to debug an xt application why do xtaddinput xtaddtimeout and xtaddworkproc work what be and how can i implement drag and drop xt glossary o the xt intrinsic implement an object orient interface to c code to allow useful graphical component to be create included with thi be class that provide the base functionality object rectobj core composite constraint shell overrideshell wmshell etc the term xt and intrinsic be use interchangeably however they be use very precisely to mean a specific library of the x window system in particular it do not include the athena motif olit or any other widget set without further widget the intrinsic be not especially useful o a widget refer to a user interface abstraction create vium xt the precise use be any object that be a subclas of the core clas it be use loosely to refer to anything that be a subclas of the object clas although these be more accurately call windowles widget or gadget o xlib be the c interface to the protocol it be one layer below the xt intrinsic typically a widget use relatively few xlib function because xt provide most such service although an understand of xlib help with problem software version the follow be the latest version of xt base software software version released next expected patch none patch athena widget see motif olit xtra xw none xcu none fwf related faq david b lewi uunet craft faq maintain the faq on x it be post monthly on and locate on export in liam r e quin lee post an faq list on open look to jan newmarch jan post an faq list on motif to peter ware ware post an faq list for it be on export in why do my application core dump when i use in brief xlib xt and most widget set have no mutual exclusion for critical section any interrupt handler be likely to leave one of the above library in an inconsistent state such a all the appropriate flag not yet set dangle pointer in the middle of a list traversal etc note that the ansi c standard point out that behavior of a signal handler be undefined if the signal handler call any function other than signal itself so thi be not a problem specific to xlib and xt the posix specification mention other function which may be call safely but it may not be assume that these function be call by xlib or xt function the only safe way to deal with signal be to set a flag in the interrupt handler thi flag later need to be check either by a work procedure or a timeout callback it be incorrect to add either of these in the interrupt handler a another note it be dangerou to add a work procedure that never finish thi effectively preempt any work procedure previously add and so they will never be call another option be to open a pipe tell the event loop about the read end use xtappaddinput and then the signal handler can write a byte to the write end of the pipe for each signal however thi could deadlock ymy proces if the pipe fill up why do the intrinsic deal with thi problem primarily because it be suppose to be a portable layer to any hardware and operate system is that a good enough reason i do think so note the article in the x journal and the example in volume be in error how do i use a different visual than the default thi require a more complicate answer than it should a window ha three thing that be visual specific the visual colormap and border pixmap all widget have their own colormap and borderpixmap resource only shell widget have visual resource another question deal with why shell have a visual the default value of these resource be copyfromparent which do exactly what it say in the shell widget copyfromparent get evalulated a defaultvisualofscreen and defaultcolormapofscreen when any one of the three resource be not properly set a badmatch error occur when the window be create they be not properly set because each of the value depend on the visual be use how to get thi to work there be two part to the answer the first be if you want an application to start with a particular visual and the second be if you want a particular shell within an application to start with a different visual the second be actually easier because the basic information you need be available the first be a little harder because you need to initialize much of the toolkit yourself in order to determine the need information some sample code to start up an application use something other than the default visual to compile cc g o visual lxaw lxmu lxt lxext lm to run visual geometry depth visual staticcolor fg blue bg yellow you need to move the mouse to get the particular visual colormap to install include include include typedef struct visual visual int depth optionsrec optionsrec option xtresource resource visual visual xtrvisual sizeof visual xtoffsetof optionsrec visual xtrimmediate null depth depth xtrint sizeof int xtoffsetof optionsrec depth xtrimmediate null xrmoptiondescrec desc visual visual xrmoptionseparg null depth depth xrmoptionseparg null int main argc argv int argc char argv xtappcontext app the application context widget top toplevel widget display dpy display char xargv save argument vector int xargc save argument count colormap colormap create colormap xvisualinfo vinfo template for find visual xvisualinfo return list of visual int count number of match only arg arg cardinal cnt char name test char clas test save the command line argument xargc argc xargv char xtmalloc argc sizeof char bcopy char argv char xargv argc sizeof char the follow create a dummy toplevel widget so we can retrieve the appropriate visual resource cnt top xtappinitialize app clas desc xtnumber desc argc argv string null arg cnt dpy xtdisplay top cnt xtgetapplicationresource top option resource xtnumber resource arg cnt cnt if defaultvisualofscreen xtscreen top xtsetarg arg cnt xtnvisual cnt now we create an appropriate colormap we could use a default colormap base on the clas of the visual we could examine some property on the rootwindow to find the right colormap we could do all sort of thing colormap xcreatecolormap dpy rootwindowofscreen xtscreen top allocnone xtsetarg arg cnt xtncolormap colormap cnt now find some information about the visual xvisualidfromvisual xgetvisualinfo dpy visualidmask vinfo count if count xtsetarg arg cnt xtndepth depth cnt xfree xpointer xtdestroywidget top now create the real toplevel widget xtsetarg arg cnt xtnargv xargv cnt xtsetarg arg cnt xtnargc xargc cnt top xtappcreateshell char null clas applicationshellwidgetclas dpy arg cnt display the application and loop handle all event xtrealizewidget top xtappmainloop app return which visual should an application use thi be a point that can be argue about but one opinion be there be no way for an application to know the appropriate visual it ha to be specify by the user if you disagree with thi then ymy application probably fall into the category of alway use the default visual or it be hardware specific and expect some particular visual such a truecolor with an overlayplane extension or some such why no application run in isolation depending on the way a server allocate resource i may not alway want ymy application to run in truecolor mode if it be go to me up my other application i may be very upset if it choose to run in greyscale instead of psuedocolor or just monochrome a an example on a low end color sun server there be many different possible visual monochrome entry colormap static gray static color and a truecolor the sgi iri offer all the above plu bite truecolor bite truecolor an overlay plane why do only shell widget have a visual thi be strictly by convention it make it possible for an arbitrary widget to know that the visual it use can be find by look for the shell widget that be it ancestor and obtain the visual of that shell a widget can have it own visual resource if it do it must have it own realize method to use the visual when it call xcreatewindow you should also make thi a resource that can be obtain with xtgetvalue so other widget can find it a reasonable value be probably xtnvisual which visual depth and colormap do shell inherit the default value for these resource be set to copyfromparent thi be interpret a the defaultcolormapofscreen defaultdepthofscreen and the default visual of the screen if the widget ha no parent it be an applicationshellwidgetclas and the root of ymy widget tree if the parent of the widget be not null then the shell copy colormap and depth from it parent and use copyfromparent a the visual i do all the above and i still get a badmatch error why some resource converter improperly cache reference thi wa especially true of and earlier version of motif why do my widget get destroy when i call xtdestroywidget see section of the xt specification it eventually do get destroy just not immediately the intrinsic destroy a widget in a two-phase proces first it and all of it child have a flag set that indicate it be be destroy it be then put on a list of widget to be destroy thi way any pending x event or further reference to that widget can be clean up before the memory be actually free the second phase be then perform after all callback event handler and action have complete before check for the next x event at thi point the list be traverse and each widget memory be actually free among other thing a some further the widget may be destroy if the intrinsic determine that they have no further reference to the widget on the list if so then the phase destruction occur immediately also if nest event loop be use widget place on the destroy list before enter the inner event loop be not destroy until return to the outer event loop how do i exit but still execute the destroycallback the problem be if a simple and entirely reasonable approach to exit an application be use such a call exit directly then a widget may not have a chance to clean up any external state such a open socket temporary file allocate x resource etc thi code for simplicity reason assume only a single toplevel widget widget toplevelget gw widget gw widget to find toplevel widget top for top gw xtparent top top xtparent top empty return top void exitcallback gw closure widget gw widget xtpointer closure datum the app specify xtpointer widget specific datum widget toplevel toplevel toplevelget gw xtunmapwidget toplevel make it disappear quickly xtdestroywidget toplevel exit one can see that the above code exit immediately after destroy the toplevel widget the trouble be the phase destruction may never occur thi work for most widget and most application but will not work for those widget that have any external state you might think that since it work now it will alway work but remember that part of the reason an object orient approach be use be so one can be ignorant of the implementation detail for each widget which mean that the widget may change and someday require that some external state be clean up by the destroy callback one alternative be to modify exitcallback to set a global flag and then test for that flag in a private event loop however private event loop be frown upon because it tend to encourage sloppy and difficult to maintain practice try the follow code instead include extern widget toplevelget if needfunctionprototype widget gw endif extern boolean exitworkproc if needfunctionprototype xtpointer closure endif extern void exitcallback if needfunctionprototype widget gw xtpointer closure xtpointer endif widget toplevelget gw widget gw widget to find toplevel widget top for top gw xtparent top top xtparent top empty return top void exitcallback gw closure widget gw widget xtpointer closure datum the app specify xtpointer widget specific datum widget toplevel toplevel toplevelget gw xtunmapwidget toplevel make it disappear quickly xtdestroywidget toplevel xtappaddworkproc xtwidgettoapplicationcontext gw exitworkproc xtpointer null boolean exitworkproc closure xtpointer closure exit notreached exitcallback add a work procedure that will get call when the application be next idle which happen after all the event be process and the destroy callback be execute how do i resize a shell widget after it be realize one do resize a shell widget the proper thing be to resize the currently manage child of the shell widget use xtsetvalue the geometry change be then propagate to the shell which ask the window manager which may or may not allow the request however the shell must have the resource xtnallowshellresize set to true otherwise it will not even ask the window manager to grant the request and the shell will not resize to change the position of a shell use xtsetvalue on the shell not the child and within the limit of the window manager it should be grant why ca xtappaddinput handle file it do however unix semantic for when be ready for a file do not fit most people intuitive model in unix term a file descriptor be ready for read whenever the read call would not block ignore the set of optional flag that indicate not to block thi work a expect for terminal socket and pipe for a file the read will alway return but the return indicate an eof no more datum the result be the code in the intrinsic alway call the input handler because it alway think something be about to be read the culprit be the select system call or on sysv base o it be the poll system call how to get around thi on a unix system the best approach be to use another proces to check for available input on the file use a pipe to connect the application with thi other proces and pa the file descriptor from the pipe to xtappaddinput a suitable program on bsd system be tail f filename it rumor that select on some system be not completely reliable in particular ibm aix thi be one where it would work for a while several thousand time and then stop until some other event wake it up thi seem to be the result of a race condition in the kernel ibm claim to have a fix for thi pyramid do work at all ultrix and possibly other where pipe be implement a socket wa completely break but although the write side write in byte block the read side receive it all break up a if it wa be put into the pipe a byte at a time you can waste a lot of time by read small block get raound it by detect the situation and have select ignore the pipe for msecond by then it have be give the whole block note that all the above description use unix terminology such a read file descriptor pipe etc thi be an o dependent area and may not be identical on all system however the intrinsic designer felt it wa a common enough operation that it should be include with part of the toolkit why they do also deal with signal at thi point i do know what good book and magazine be there on xt i have a favorite that be the definitive reference to my perspective it offer a reasonable introduction but also go into the full detail of the intrinsic when i start use it i wa already familiar with xt and the concept behind it so newcomer may or may not find it useful i alway find it accurate and complete which mean it a page asente paul j and swick ralph r x window system toolkit the complete programmer guide and specification digital pres isbn order number and by prentice-hall isbn also available through dec direct at the other book i commonly recomend to novice be young doug the x window system application and programming with xt motif version prentice hall isbn isbn and of course ha an entire series of manual on x and xt order be in particular volume be an xt reference do in manual page style the edition be extensively overhaul and go far beyond the mit manual page i find it very useful in particular the permutted index and reference to other manual page help a great deal in chase down relate information i read two periodical the x resource and the the x journal these be the only two deal specifically with x the x resource be publish quarterly by with one of the issue be the mit x consortium technical conference proceedings there be no advertise i find it informative with pretty good depth for order call or email cathyr for editorial matter email adrian table of content be post at in in tex form and on in in ascius form the x journal be a bimonthly trade rag with lot of advertise the article be informative and orient toward a le technical audience i read it more to see what go on then with an expectation of learn a great deal but remember i represent a fairly small percentage of person also they have a pretty good collection of person on the advisory board and a columnist call what widget be available there be three popular widget set athena the set provide with thi be sufficient for most purpose but be on the ugly side recently a look be available for ftp on motif from osf available for a license fee and commonly ship on many workstation vendor platform almost everyone but sun it look good and work well but personally i think it be poorly implement olit the open look intrinsic toolkit be a set of widget implement sun open look specification developed by at t i never use it so ca comment on it quality i hear rumour that it be a pain to actually get in addition the follow collection of widget be also available xtra a library of widget for sale from graphical software technology it include bar graph stack bar graph line graph pie chart xy plot hypertext help spreadsheet and datum entry form widget i never see them so i ca comment fwf the free widget foundation be attempt to collect a set of freely available widget included be a pixmap editor filedialog and a few other the current set of widget can be obtain vium anonymou ftp from the machine in the file xcu the cornell university widget from gene dyke one of the early widget set release provide a nice appearance for button and ha a mini command language probably not so widely use x the sony widget set thi wa around during day but seem to disappear it look like it have promise xw the hp widget the precursor to motif originally write for there exist diff to get it to work under again a pretty good widget set but ha more or le die the precursor to thi wa the xray toolkit which wa originally implement for and apparently provide much experience for the designer of xt xo a widget set i work on it still primitive but you can give it a try in the follow specialize widget be also available tbl implement a tabular layout of widget support motif widget a child part of wcl plot the athena plotting widget not the athena widget contact gnb or joe what alternative to the intrinsic be there name language vendor xview c sun ous c parcplace interview c stanford c however much i like c and admire the skill in both design and implement the intrinsic hopefully some alternative will develop in the next year that use an object orient language keep ymy eye open and expect some change about the same time a language other than c start gain acceptance how do i pa a float value to xtsetvalue first what be go wrong be the structure for an arg be essentially typdef struct string name long value arg and the code arg arg xtsetarg arg name expand to arg arg name you can see that with normal c type conversion the get the integer instead of the float point value when the value be copy into the widget resource the bite pattern be wildly different than that require for a float point value so how to get around thi the follow macro be from the athena widget document and i be now recomending it over the previou suggestion define xtsetfloatarg arg n d if sizeof float sizeof xtargval xtsetarg arg n d else xtargval ld xtargval d xtsetarg arg n ld how do i write a resource converter courtesy of rich thomson rthomson the follow discussion of resource converter assume or intrinsic resource converter change between and to allow for destructor and cache of convert value there be several main type of resource converter string to datum type datum type to string datum type to datum type i string to datum type usually a string to datum type converter ha a fix set of string that will be convert to datum type value thi be most often use to map enumerate name to enumerate value name value true false in thi case the string to datum type converter need to compare the resource value to the list of fix string thi be most readily accomplish by the use of the quark mechanism of the resource manager the resource value be turn into a quark which be a unique representation of the string that fit into a single word then the resource quark be compare against the quark for the fix string represent the enumerate value if there be many enumerate string in the converter or many converter each with a small number of enumeration string then a global initialization routine might be use to turn all the resource string into quark that way the first time one of these converter be use the string will be turn into quark and hold in static variable for use in the next invocation of one of the converter ius datum type to string thi type of converter be slightly easier than the string to datum type converter since the use of quark be necessary instead the datum type value be simply convert to a string value probably by the use of sprintf datum type to string converter be useful for application that wish to convert an internal datum type value into a string so that they can write out a valid resource specification to a file thi mechanism can be use to provide a snapshot of application state into a file thi snapshot can be use to restore the program to a know state vium the usual x resource database mechanism if you be take the trouble to write a string to datum type converter it be much extra effort to write the datum type to string converter writing both at the same time help to ensure that they be consistent iius datum type to datum type thi type of converter be use to convert an exist datum type value to another datum type for instance an x pixel value can be convert to an rgb datum type that contain separate field for red green and blue the type signature for a resource converter be a follow typedef boolean xttypeconverter display xrmvalueptr cardinal xrmvalueptr xrmvalueptr xtpointer display dpy xrmvalueptr arg cardinal xrmvalueptr fromval xrmvalueptr toval xtpointer when the converter be invoke the fromval argument point to the source x resource manager value and the toval argument point to the destination x resource manager value the argument be an opaque pointer to some converter-specific datum that be specify when the converter be register the arg and argument allow extra information to be pass to the converter when it be invoke for instance the pixel to rgb structure converter discuss above would need colormap and visual argument in which to lookup the pixel to obtain the rgb value correspond to that pixel care must be take with the toval argument an xrmvalue ha the follow type definition and specify a size and location for a convert value typedef struct unsigned int size addr xrmvalue xrmvalueptr when the converter be invoke the addres may point to a location of the give size for the convert value or the location can be null in the former case the converter should ensure that the size of the destination area be large enough to handle the convert value if the destination area be not large enough then the converter should set the size to the amount of space need and return false the caller can then ensure that enough space be allocate and reinvoke the converter if the size be large enough then the converter can simply copy the convert value into the space give and return true if the location be null then the converter can assign the location to the addres of a static variable contain the convert value and return true when write a group of converter thi code be often repeat and it become convenient to define a macro define done var type if toval addr if toval size sizeof type toval size sizeof type return false else type toval addr var else toval addr var toval size sizeof type return true define donestr str if toval addr toval size sizeof string toval size sizeof string return false else toval addr str toval size sizeof string return true inside the converter it be a good idea to perform a little safety check on the and arg argument to ensure that ymy converter be be call properly once you have write ymy converter you need to register it with the intrinsic the intrinsic invoke resource converter when create widget and fetch their resource value from the resource database to register a converter with a single application context use xtappsettypeconverter void xtappsettypeconverter context from to converter arg cache destructor xtappcontext context string from string to xttypeconverter converter xtconvertarglist arg cardinal xtcachetype cache xtdestructor destructor to register a converter with all application context use xtsettypeconverter void xtsettypeconverter from to converter arg cache destructor string from string to xttypeconverter converter xtconvertarglist arg cardinal xtcachetype cache xtdestructor destructor in the intrinsic there be the routine xtappaddconverter and xtaddconverter these have be supersede by xtappsettypeconverter and xtsettypeconverter whenever possible the newer routine should be use when a converter be register with the intrinsic a cache argument specify how convert resource value be to be cache xtcachenone do cache any convert value xtcacheall cache all convert value xtcachebydisplay cache convert value on a per display basi caching convert value that require a round-trip to the server be a good idea for instance string to pixel conversion the destructor argument be a routine that be invoke then the resource be destroy either because it cache reference count ha be decremented to zero or because the widget own the value be be destroy xtdestructor ha the follow type definition typedef void xtdestructor xtappcontext xrmvalueptr xtpointer xrmvalueptr cardinal xtappcontext context xrmvalueptr to xtpointer xrmvalueptr arg cardinal the destructor be invoke to free any auxiliary storage associate with the to argument but do not actually free the storage point to by the to argument itself to addr the destructor be pass the extra argument that be pass to the converter when the conversion wa perform for instance colormap and visual argument for the string to pixel converter since the destructor would need to free the allocate pixel from the colormap a well a the private datum pass in when the converter wa register sample converter code can be find in the follow file in the mit distribution how do i open multiple display see multi-user application software using xt the x resource issue summer by oliver jone for a complete coverage of the issue involve most of thi answer be base on that article in a nutshell one use xtopendisplay to add each display to a single application context and then xtclosedisplay to shutdown each display and remove it from the application context the real problem occur when try to close down a display thi can happen way user select a quit button on one of the display user ha window manager send a message server disconnect possibly from a killclient message server or network failure i assume you can deal gracefully with since it be merely a problem of translate a widget to a display and remove that display if not then read the oliver jone article the third one be difficult to handle the follow be base on the oliver jone article and i include it here because it be a difficult problem the difficulty arise because the xlib design presume that an error be alway unrecoverable and so fatal thi be essentially true for a single display x base application but not true for a multiple display program or an application that do thing other than display information on an x server when an x error occur the error handler be call and if it return then an exit happen the only way around thi be to use to avoid return to the error handler the follow code fragment demonstrate thi include xiorecover void xiohandler dpy display dpy destroydisplay dpy longjmp xiorecover main if setjmp xiorecover xsetioerrorhandler xiohandler xtappmainloop the destroydisplay be something that give a display pointer can go back to the application specific datum and perform any necessary cleanup it should also call xtclosedisplay for those of you unfamiliar with when setjmp be first call it return a and save enough information in the that a latter execution of longjmp can return the program to the same state a if the setjmp wa just execute the return value of thi second setjmp be the value of the second argument to longjmp there be several caveat about use these but for thi purpose it be adequate some other problem you might run into be resource converter that improperly cache resource the most likely symptom be xlib error such a badcolor badatom or badfont there may be problem with the total number of display you can open since typically only a limit number of file descriptor be available with be a typical value you may also run into authorization problem when try to connect to a display there wa much discussion in about thi topic in november of robert scheifler post an article which basically say thi be the way it will be and xlib will not change what change from to to thi address only change in the intrinsic first the general change for each release be describe then a certainly incomplete list of new function add and other that be now deprecate be list brevity be a primary goal much of the follow information be retrieve from chapter of the mit xt intrinsic manual and from volume edition from to addition of gadget windowles widget new resource type converter interface to handle cache and additional datum variable argument list interface define xtspecificationrelease add with thi release wmshellpart toplevelshellpart transientshellpart change incompatibly add arglist and count parameter event handler have parameter add specification change change to an enumerate datum type from boolean change to enumerate datum type from boolean add to extension record obsolete a info be pass to add to extension record obsolete a info be pass to calling xtquerygeometry must store complete geometry added unrealizecallback xttranslatecoord actually work under from to psuedo resource basetranslation add searching for app-default and other file make more flexible customization resource add per-screen resource database support permanently allocate string permanetly allocate string require for several clas field the arg argument to xtappinitialize xtvaappinitialize xtopendisplay xtdisplayinitialize and xtinitialize be change from cardinal to int many performance improvement thi be summarize from the article xt performance improvement in release by gabe beged-dov in the x resource issue xrmstringtoquark augment with xrmpermstringtoquark to avoid string copy several field in the clas record be indicate a need permanent string using an array of string for resource callback list redesign to use le memory translation manager redesign and rewrite so it take le memory translation table merge be faster cache of action bind keycode to keysym be cache better share of gc with modifiable field window to widget translation use le space and faster do not malloc space for widget name since quark be available widget space be allocate to include the constraint over several example program about a reduction in memory usage function new with xtallocategc sharable gc with modifiable field xtgetactionlist get the action table of a clas xtscreendatabase return resource database for a screen xtsetlanguageproc register language procedure call to set locale function new with xtappaddactionhook procedure to call before every action xtappinitialize lot of initialization work xtappreleasecacheref decrement cache reference count for converter xtappsetfallbackresource specify default resource xtappsettypeconverter register a new style converter xtcallcallbacklist directly execute a callback list xtcallconverter invoke a new style converter xtcallbackreleasecacheref release a cache resource value xtcallbackreleasecachereflist release a list of cache resource value xtconvertandstore find and call a resource converter xtdirectconvert invoke old-style converter xtdisplayofobject return the display xtdisplaystringconversionwarning issue a warn about conversion xtfindfile find a file xtgetactionkeysym retrieve keysym modify for thi action xtgetapplicationnameandclas return name and clas xtgetconstraintresourcelist get constraint for a widget xtgetkeysymtable return keycode-to-keysym map table xtgetmulticlicktime read the multi-click time xtgetselectionrequest retrieve the selectionrequest event xtgetselectionvalueincremental obtain the selection value incrementally xtgetselectionvaluesincremental obtain the selection value incrementally xtinitializewidgetclas initialize a widget clas manually xtinserteventhanlder register event handler other xtinsertraweventhandler register event handler without modify input mask xtisobject test if subclas of object xtisrectobj test if subclas of rectobj xtkeysymtokeycodelist return list of keycode xtlasttimestampprocessed retrieve most recent event time xtmenupopdown action for pop down a widget xtmenupopup action for pop up a widget xtoffsetof macro for structure offset xtownselectionincremental make selection datum availabe incrementally xtpoupspringloaded map a spring-loaded popup xtregistergrabaction indicate action procedure need a passive grab xtremoveactiohhook remove function call after every action xtresolvepathname find a file xtscreenofobject return screen of object xtsetmulticlicktime set the multi-click time xtsetwmcolormapwindow set for custom colormap xtungrabbutton cancel a passive button grab xtungrabkey cancel a passive key grab xtungrabkeybard release an active keyboard grab xtungrabpointer release an active pointer grab xtva varag interface to a bunch of function xtwindowofobject return window of nearest widget ancestor deprecated replacement when xtaddaction xtappaddaction xtaddconverter xtappaddconverter xtaddinput xtappaddinput xtaddtimeout xtappaddtimeout xtaddworkproc xtappaddworkproc xtconvert xtconvertandstore xtcreateapplicationshell xtappcreateshell xtdestroygc xtreleasegc xterror xtapperror xtgeterrordatabase xtappgeterrordatabase xtgeterrordatabasetext xtappgeterrordatabasetext xtgetselectiontimeout xtappgetselectiontimeout xtinitialize xtappinitialize xtmainloop xtappmainloop menupopdown action xtmenupopdown action menupopup action xtmenupopup action xtnextevent xtappnextevent xtpeekevent xtapppeekevent xtpending xtapppending xtseterrorhandler xtappseterrorhandler xtseterrormsghandler xtappseterrormsghandler xtsetselectiontimeout xtappsetselectiontimeout xtsetwarninghandler xtappsetwarninghandler xtsetwarningmsghandler xtappsetwarningmsghandler xtwarning xtappwarning xtwarningmsg xtappwarningmsg where be the resource load from the resource of a widget be fill in from the follow place from highest priority to lowest priority arg pass at creation time command line argument user per host default file user default file user per application default file system wide per application default file note that be read only once on application startup the result of step be a single resource database use for further query the per host default file contain customization for all application execute on a specific computer thi file be either specify with the xenvironment environment variable or if that be not set then the file host be use the user default file be either obtain from the property on the root window of the display or if that be not set then the file be use typically the program xrdb be use to set the property please note that thi should be keep relatively small a each client that connect to the display must transfer the property a size of around be reasonable some toolkit may track change to the but most do not a user may have many per application default file contain customization specific to each application the intrinsic be quite flexible on how thi file be find read the next part that describe the variou environment variable and how they effect where thi file be find the system wide per application default file be typically find in if such a file be not find then the fallback resource be use the intrinsic be quite flexible on how thi file be find read the next part that describe the variou environment variable and how they effect where thi file be find thank to oliver jone oj for the follow you can use several environment variable to control how resource be load for ymy xt-based program xfilesearchpath xuserfilesearchpath and xapplresdir these environment variable control where xt look for application-default file a an application be initialize xt load at most one app-default file from the path define in xfilesearchpath and another from the path define in xuserfilesearchpath set xfilesearchpath if software be instal on ymy system in such a way that app-default file appear in several different directory hierarchy suppose for example that you be run sun open window and you also have some x application instal in you could set a value like thi for xfilesearchpath and it would cause xt to look up app-default file in both and or wherever ymy openwinhome be locate setenv xfilesearchpath t n t n the value of thi environment variable be a colon-separated list of pathname the pathname contain replacement character a follow see xtresolvepathname n the value of the filename parameter or the application clas name t the value of the file type in thi case the literal string app-default c customization resource only s suffix none for app-default l language locale and codeset l language part of l ja t the territory part of the display language string c the codeset part of the display language string let take apart the example suppose the application clas name be myterm also suppose open window be instal in notice the example omit locale-specific lookup t n mean t n mean a the application initialize xt try to open both of the above app-default file in the order show a soon a it find one it read it and use it and stop look for other the effect of thi path be to search first in then in let consider another example thi time let set xuserfilesearchpath so it look for the file in the current work directory then for myterm in the directory app-default setenv xuserfilesearchpath n the first path in the list expand to the second expand to thi be a convenient set for debug because it follow the imake convention of name the app-default file in the application source directory so you can run the application from the directory in which you be work and still have the resource load properly note when look for app-default file with xuserfilesearchpath for some bizarre reason neither the type nor file suffix be define so t and s be useles with there another twist you may specify a customization resource value for example you might run the myterm application like thi myterm xrm customization color if one of ymy pathname specification have the value n c then the expand pathname would be because the c substitution character take on the value of the customization resource the default xfilesearchpath compile into xt be l t n c l t n c t n c l t n l t n t n note some site replace with a projectroot in thi batch of default set the default xuserfilesearchpath also compile into xt be root l n c root l n c root n c root l n root l n root n root be either the value of xapplresdir or the user home directory if xapplresdir be not set if you set xuserfilesearchpath to some value other than the default xt ignore xapplresdir altogether notice that the quick and dirty way of make ymy application find ymy app-default file in ymy current work directory be to set xapplresdir to a single dot in all thi machinery work differently for compatibilty many person set their xapplresdir value to a dot follow by a slash what order be callback execute in courtesy of donna converse converse the intrinsic library do not guarantee an order thi be because both the widget writer and the application writer have the ability to modify the entire content of the callback list neither one currently know what the other be do and so the intrinsic can not guarantee the order of execution the application programmer can not rely on the widget writer the widget writer be not require to document when the widget will add and remove callback from the list or what effect thi will have therefore the functionality contain in a callback should be independent of the functionality contain in other callback on the list even though the xt standard in the definition of xtaddcallback say specify the callback list to which the procedure be to be append you may not infer from the word append that the callback routine be call in the same order a they have be add to the callback list how do i know if a widget be visible courtesy of donna converse converse i be build a widget need to know if it be visible i set the visible interest field in core and if my window be completely obscure the core visible flag go false however if my window be iconified the flag stay set to true right everything be implement correctly thi demonstrate a deficiency in the x protocol and the core widget be reflect the capability of the protocol the deficiency be that the information be available in one way in thi case an inconvenient way the xt specification be accurate in the second and third paragraph of section so read thi section carefully the visible field will not change in response to iconification a visibilitynotify event will not be receive when the window go from viewable to unviewable that be when the widget or an ancestor be unmapped that be when iconification occur thi be the protocol deficiency visibility state and viewable state have specific mean in the x protocol see the glossary in ymy xlib and x protocol reference manual is thi a problem with mwm or be there something else which need to be do you see thi with any window manager with no window manager if the problem be mwm what be the fastest way to determine if a window be iconified a an application writer keep track with a global boolean in an action routine with translation for mapnotify and unmapnotify on the shell widget which contain ymy custom widget a the custom widget writer see the field return by a call to xgetwindowattribute these be suggestion how do i reparent a widget in xt xtreparentwidget you ca why use xtmalloc xtfree etc unfortunately most code that call malloc realloc or calloc tend to ignore the possibility of return null at best it be handle something like ptr type malloc sizeof type if ptr perror malloc in xyzzy exit to handle thi common case the intrinsic define the function xtmalloc xtcalloc xtnew xtnewstring and xtrealloc which all use the standard c language function malloc calloc and realloc but execute xterrormsg if a null value be return xt error handler be not suppose to return so thi effectively exit in addition if xtrealloc be call with a null pointer it use xtmalloc to get the initial space thi allow code like if ptr ptr type malloc sizeof type else ptr type realloc ptr sizeof type count count to be write a ptr xtrealloc ptr sizeof ptr count also xtfree accept a null pointer a an argument generally i find the xt function conveniant to use however anytime i allocate anything potentially large i use the standard function so i can fully recover from not enough memory error xtnew and xtnewstring be conveniant macro for allocate a structure or copy a string struct abc xyzzy char ptr char str abcdef xyzzy xtnew struct abc take care of type cast ptr xtnewstring str a strict interpretation of the intrinsic reference manual allow an implementation to provide function that be not exchangable with malloc and free code such a char ptr ptr xtmalloc free ptr may not work personally i call any implementation that do thi break and complain to the vendor a common error for motif programmer be to use xtfree on a string when they should really be use xmstringfree how to debug an xt application first i recomend get purify from pure software thi be a great package for trace memory problem on sun it a bite pricey at but i still recomend it excuse the market blurb contact support for more info purify insert additional check instruction directly into the object code produce by exist compiler these instruction check every memory read and write perform by the program under test and detect several type of acces error such a read unitialized memory write past malloc bind or write to free memory purify insert check logic into all of the code in a program include third party and vendor object-code library and verify system call interface in addition purify track memory usage and identify individual memory leak use a novel adaption of garbage collection technique purify nearly comprehensive memory acces check slow the target program down typically by a factor of two to five an alternative package that be a pricey for a sun run on many unix and ha pretty similar feature be the sentinel debugging environment thi replace malloc and several other c library function to add additional check contact cpcahil for more info next if you be get any sort of xlib error you need to run in synchronou mode easily accomplish with the sync command line argument or by set the variable xdebug to with ymy debugger then set a break point in exit thi will let you trace back to the original xlib function be call if you do run in synchronou mode then the actual error may have occur any number of call to xlib previously since the xlib call be buffer and reply from the server be asynchronou next if you be have trouble with window layout you can use the undocumented resource xtidentifywindow or the clas resource xtdebug to cause the widget name to be identify with each window for example example xload xrm true example xwininfo tree click in new xload window will give the normal information but the widget name and clas of each window be include thi can help for check the location and size of errant widget next if you be have trouble with geometry manager or you want to test the way a widget manage it child you can try thi act a a filter between any child and a geometry manager and check the behavimy of both it a very clever idea the most unfortunate problem be debug a callback while the application be execute a grab of the keyboard or mouse such a from a pulldown menu the server effectively lock up and you need to go to another machine and kill the debugger manually the server lock up because the application be debug ha say no one else can have acces to the keyboard but the application be not stop wait because the debugger be wait for ymy command unfortunately you ca give them because all the input be go to ymy application which be stop the best way to debug thi kind of problem be with two machine on ymy desk run the program under a debugger or other environment on one machine and run the application on the other possibly use a command sequence like thi othermachine xhost thismachine thismachine setenv display thismachine gdb application ymy favorite debugger or thi othermachine xhost thismachine thismachine gdb application gdb set environment display gdb run i believe codecenter a c debugger ha a method of deal with thi by explicitely call the xlib function to release any grab during breakpoint debugging widget problem require pretty good debug skill and knowledge of how widget work you can go a long way without know the internal of a particular widget but not very far without understand how a widget work judiciou use of conditional breakpoint and add print statement with the debugger help a great deal why do xtaddinput xtaddtimeout and xtaddworkproc work i have get a delicate problem with the three routine xtaddinput xtaddtimeout and xtaddworkproc the problem i have be that when i use them in my application they seem not to be registred properly i have make a handy little testprogram where everything work perfect but in my real application nothing happen the introduction in of the xtapp function obsoleted those routine see for other change in and what happen be they use a default application context different then the one you may have create since event and timeout be distribute on a per application context basi and you be use two application context you wo get those event for example cnt toplevel xtappinitialize app clas desc xtnumber desc argc argv fallback arg cnt xtaddtimeout xtaddworkproc xtappmainloop app would never invoke the timeout what be and how can i implement drag and drop courtesy of roger reynold rogerr feb drag-n-drop be a buzzword for move datum between client in an intuitive fashion motif version support drag-n-drop capability openlook ha support d-n-d all along the two protocol be not compatable with each other and so far a i know they be not publish i write a package call rdd which be design to be a flexible public protocol for do drag drop operation between client my intention wa to provide a tool which would make it easy for person to support a standard drag-n-drop protocol in the program they develop and contribute or sell regardles of what widget set be use a long a it be base on xt the implementation be base upon my understand of the icccm convention for more detail read the code i have hear from dozen of person use rdd who like it and feel that it work a whole lot better than motif stuff also there seem to be many who think that it be neat but be constrain to use motif anyway the latest rdd and some other stuff be available for ftp from in a possibly older version be also available on in contrib pete ware ware ci dept ohio state university w bolz hall neil ave h columbu oh 