from ninassup niko i nassuphi subject lga ncrypt source i get a number of request for code so here it be it write in asm borland tasm will do tasm tlink t the code lga ncryption c by nick nassuphi code segment assume cs code d code org start jmp begin ga particle assigment bit particle move east bit particle move west bit particle move north bit particle move south bit particle move east bit particle move west bit particle move north bit particle move south collisiong rule ga rule if e w and n s then e w n s if n s and e w then n s e w for nibble and for byte reflection rule just swap bite along direction thi look-up table implement two particle collision for the hpp lattice ga hpprule db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db thi rule implement the velocity-reversal need to run the ga evolution in reverse it call a wallrule because it the same a be all particle hit a wall head on wallrule db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db db maxbyte equ lineno equ srcptr dw offset desptr dw offset savebuff db maxbyte dup db maxbyte dup db dup db maxbyte dup db dup datum db db db db thi be a test for a lattice ga base encryption db algorithm the datum be encode a particle of a db digital ga whose time evolution be then simulate db with a cellular-automaton type algorithm decryption db can be achieve by run the simulation in reverse db a thermodynamic argument ensure that even if a single db bite be flip no decryption of the datum be possible db db after the ga be let to evolve for timestep db one can either run the reverse evolution by press db space or flip a bite and then run by press db db for a cryptographic application the key would consist db of the number of time step and the time and location db of specific bite inversion db db db db db fill the ga with a piece of code initga mov di cs srcptr mov si offset datum mov cx lineno push di push cx mov cx maxbyte mov al cs si mov cs di al inc si inc di loop pop cx pop di add di maxbyte loop mov si cs srcptr mov di offset initga mov cx mov mov byte ptr cs si al not al inc si loop ret display ga molecule bounce around showga push es push si push di push cx push bx mov mov es ax mov si cs srcptr mov mov cx add si push cx push di mov cx maxbyte mov al cs si mov byte ptr es di al inc si add dec cx jnz pop di pop cx add loop pop bx pop cx pop di pop si pop es ret cs si sourse of datum cs di destination of datum scanonemiddleline first byte be a special case because of warparound mov al be the assemble byte mov bh cs si-maxbyte north be one line up lower and and at bite and or bl bh or them into the assemble byte mov bh cs south be one line down higher and and at bite and or bl bh place the stuff into al mov bh cs si west be one byte leave lower and and at bite and or bl bh mov bh cs east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di middle byte can be handle in a loop mov cx mov al be the assemble byte mov bh cs si-maxbyte north be one line up lower and and at bite and or bl bh or them into the assemble byte mov bh cs south be one line down higher and and at bite and or bl bh place the stuff into al mov bh cs west be one byte leave lower and and at bite and or bl bh mov bh cs east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di loop last byte be also special mov al be the assemble byte mov bh cs si-maxbyte north be one line up lower and and at bite and or bl bh or them into the assemble byte mov bh cs south be one line down higher and and at bite and or bl bh place the stuff into al mov bh cs west be one byte leave lower and and at bite and or bl bh mov bh cs si east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di ret cs si sourse of datum cs di destination of datum scanfirstline first byte be a special case because of warparound mov mov bh cs and and at bite and or bl bh or them into the assemble byte mov bh cs and and at bite and or bl bh place the stuff into al mov bh cs west be one byte leave lower and and at bite and or bl bh mov bh cs east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di middle byte can be handle in a loop mov cx mov al be the assemble byte mov bh cs and and at bite and or bl bh or them into the assemble byte mov bh cs and and at bite and or bl bh place the stuff into al mov bh cs west be one byte leave lower and and at bite and or bl bh mov bh cs east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di loop last byte be also special mov al be the assemble byte mov bh cs and and at bite and or bl bh or them into the assemble byte mov bh cs and and at bite and or bl bh place the stuff into al mov bh cs west be one byte leave lower and and at bite and or bl bh mov bh cs si east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al ret cs si sourse of datum cs di destination of datum scanlastline first byte be a special case because of warparound mov al be the assemble byte mov bh cs si-maxbyte and and at bite and or bl bh or them into the assemble byte mov bh cs si-maxbyte and and at bite and or bl bh place the stuff into al mov bh cs si west be one byte leave lower and and at bite and or bl bh mov bh cs east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di middle byte can be handle in a loop mov cx mov al be the assemble byte mov bh cs si-maxbyte and and at bite and or bl bh or them into the assemble byte mov bh cs si-maxbyte and and at bite and or bl bh place the stuff into al mov bh cs west be one byte leave lower and and at bite and or bl bh mov bh cs east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di loop last byte be also special mov al be the assemble byte mov bh cs si-maxbyte and and at bite and or bl bh or them into the assemble byte mov bh cs si-maxbyte and and at bite and or bl bh place the stuff into al mov bh cs west be one byte leave lower and and at bite and or bl bh mov bh cs si east be one byte right higher and and at bite and or bl bh mov mov al byte ptr cs bx offset hpprule mov cs di al inc si inc di ret invert all velocity in the ga invertall push bx push cx push si mov si cs srcptr mov mov cx lineno push cx mov cx maxbyte mov bl cs si mov al byte ptr cs bx offset wallrule mov cs si al inc si loop pop cx loop pop si pop cx pop bx ret iterateonce mov si cs srcptr mov di cs desptr mov cs srcptr di mov cs desptr si push si push di call scanfirstline pop di pop si add si maxbyte add di maxbyte mov cx dont scan first and last push si push di push cx call scanonemiddleline pop cx pop di pop si add si maxbyte add di maxbyte loop push si push di call scanlastline pop si pop di ret iterate hpp rule cx time iterate push cx call iterateonce pop cx call showga loop iterate ret iterate hpp rule cx time iterateuntil mov mov cx offset offset mov al byte ptr cs si offset xor byte ptr cs si offset al inc si loop call iterateonce call showga mov si cs srcptr mov cx mov mov mov mov bl byte ptr cs si mov dl byte ptr cs not ah xor dl ah and al dl inc si loop mov mov cx offset offset mov ah byte ptr cs and ah al xor byte ptr cs ah inc si loop jmp mov ax offset push ax ret db dup push ax push bx push cx push dx push d mov mov dx cs msgptr int pop d pop dx pop cx pop bx pop ax ret db dup msgptr dw offset msg msg db thi message be print out by db code decrypt use datum from the lattice db which wa apply to the decode routine db after every time step db the decode function leave the code unchanged db except after the ga evolution have completelly db reverse the thermalization time equ repetition be enough to equilibrate the ga begin mov mov mov mov mov int mov mov mov mov int call initga call showga mov int push cx mov cx time call iterate call invertall call showga mov int cmp al jne mov si cs srcptr xor byte ptr cs si mov cx time call iterateuntil call invertall call showga mov int code end end start 